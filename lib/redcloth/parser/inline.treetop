require File.dirname(__FILE__) + "/common"
require File.dirname(__FILE__) + "/inline/common_inline"
require File.dirname(__FILE__) + "/inline/strong"

module RedCloth
  module Parser
    grammar Inline
      include Common
      include CommonInline
      include Strong
      
      rule inline
        element_1:catchall_inline_element
        punct
        more_elements:(!li_end inline_spaces catchall_inline_element punct)* {
          def build(filter)
            Ast::Inline.new(
              all_inline_elements.map {|e| e.build(filter) }
            )
          end
          def all_inline_elements
            [element_1, punct] + more_elements.elements.map {|e| e.elements }.flatten.reject do |e|
              e.text_value.blank?
            end
          end
        }
      end
      
      rule catchall_inline_element
        inline_element / word
      end
      
      rule word
        chars {
          def build(filter)
            text_value
          end
        }
      end
      
      rule strong_inline_element
        inline_element /
        strong_word
      end
      
      rule bold_inline
        element_1:bold_inline_element
        more_elements:(inline_spaces bold_inline_element)* {
          def all_inline_elements
            [element_1] + more_elements.elements.map {|e| [e.inline_spaces, e.bold_inline_element] }.flatten
          end
        }
      end
      
      rule bold_inline_element
        bold /
        strong /
        # em /
        bold_word
      end
      
      rule bold_word
        ((
          [-'"'a-zA-Z0-9.!] / 
          '**' &(![\s\t_] .)
        )+ /
        '**') {
          def build(filter)
            text_value
          end
        }
      end
      
      rule bold
        '**' contents:bold_inline '**' {
          def build(filter)
            Ast::InlineElement.new(
              {:type => :bold},
              # contents.elements.map {|e| e.elements[1].build(filter) }
              contents.all_inline_elements.map {|e| e.build(filter) }
            )
          end
        }
      end
      # 
      # rule em
      #   '_' contents:inline '_' {
      #     def build(filter)
      #       Ast::InlineElement.new(
      #         {:type => :em},
      #         # contents.elements.map {|e| e.elements[1].build(filter) }
      #         contents.all_inline_elements.map {|e| e.build(filter) }
      #       )
      #     end
      #   }
      # end
      
    end
  end
end